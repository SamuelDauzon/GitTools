[alias]
    # ----- AVANT/PENDANT COMMIT
    # Afficher les fichiers ajoutés/modifiés (une ligne par fichier)
    st = status --short --branch
    # Visualise les différences entre le répertoire de travail et l'index
    di = diff
    # Visualise les différences entre l'index et HEAD
    dc = diff --cached
    # Ajoute les fichiers suivis et non suivis et non ignorés
    aa = add --all
    # Commite en remplaçant le dernier commit avec les changements dans l'index
    ca = commit --amend
    # Commite en remplaçant le dernier commit avec les changements des fichiers suivis
    cmf = commit -a --amend -C HEAD
    # Ajoute toutes les modifications à l'index et commite.
    ac = !git add --all && git commit -m

    # ----- LISTE DE BRANCHES
    # Affiche les branches et le dernier commit
    bv = branch -vv
    # Affiche les branches, le dernier commit et son auteur ainsi que les références
    bvv = "!f() { git for-each-ref --format='git log %(refname:short) -1 --pretty=format:\"%C(yellow)%h\\ %C(green)%ad%Cred%d\\ %Creset%s%C(cyan)\\ [%cn]%C(magenta)\\ %N\" --decorate --date=short --graph' refs/heads | sh;}; f"
    # Affiche les branches (avec les branches distantes suivies)
    ba = branch -ra
    # Liste les branches et la date de dernier commit (ordre chronologique)
    bold = for-each-ref --sort=committerdate refs/heads/ --format='%(HEAD) %(color:yellow)%(refname:short)%(color:reset) - %(color:red)%(objectname:short)%(color:reset) - %(contents:subject) - %(authorname) (%(color:green)%(committerdate:relative)%(color:reset))'
    # Liste les branches et la date de dernier commit (ordre antichronologique)
    bnew = for-each-ref --sort=-committerdate refs/heads/ --count=16 --format='%(HEAD) %(color:yellow)%(refname:short)%(color:reset) - %(color:red)%(objectname:short)%(color:reset) - %(contents:subject) - %(authorname) (%(color:green)%(committerdate:relative)%(color:reset))'
    # Liste les branches et leurs informations (ordre antichronologique)
    bnewfull = for-each-ref --sort=-committerdate refs/heads/ --format='%(HEAD) %(color:yellow)%(refname:short)%(color:reset) - %(color:red)%(objectname:short)%(color:reset) - %(contents:subject) - %(authorname) (%(color:green)%(committerdate:relative)%(color:reset))'
    # Affiche un tableau des branches avec leur statut (merged) et autres informations
    st-b = "!r() { refbranch=$1 count=$2; git for-each-ref --sort=-committerdate refs/heads --format='%(refname:short)|%(HEAD)%(color:yellow)%(refname:short)|%(color:bold green)%(committerdate:relative)|%(color:blue)%(subject)|%(color:magenta)%(authorname)%(color:reset)' --color=always --count=${count:-30} | while read line; do branch=$(echo \"$line\" | awk 'BEGIN { FS = \"|\" }; { print $1 }' | tr -d '*'); ahead=$(git rev-list --count \"${refbranch:-origin/develop}..${branch}\"); behind=$(git rev-list --count \"${branch}..${refbranch:-origin/develop}\"); ismerged=$(if git merge-base --is-ancestor "$branch" "${refbranch:-origin/develop}"; then echo "MERGED"; else echo "------"; fi); mergebase=$(git merge-base ${refbranch:-origin/develop} ${branch} | xargs git show -s --format='%cr'); shorthash=$(git rev-parse --short ${branch});colorline=$(echo \"$line\" | sed 's/^[^|]*|//'); echo \"$ahead|$behind|$ismerged|$shorthash|$mergebase|$colorline\" | awk -F'|' -vOFS='|' '{$8=substr($8,1,80)}1' ; done | ( echo \"ahead|behind|ismerged|shorthash|mergebase||branch|lastcommit|message|author\\n\" && cat) | column -ts'|'; }; r"

    # ----- LISTE DE COMMITS
    # Affiche la liste des commits avec les fichiers modifiés
    ll = log --pretty=format:'%C(yellow)%h%Cred%d %Creset%s%Cblue [%cn]' --decorate --numstat
    # Affiche la listes de commits (avec graph, auteur, date absolue, références)
    ld = log --pretty=format:'%C(yellow)%h %C(green)%ad%C(bold red)%d %Creset%s%C(cyan) [%cn]' --decorate --date=short --graph
    # Affiche la listes de commits (avec graph, auteur, date absolue précise, références)
    ldv = log --pretty=format:'%C(yellow)%h %C(green)%ad %C(bold red)%d %Creset%s%C(cyan) [%cn]' --decorate --date=format-local:'%Y-%m-%d %H:%M:%S' --graph
    # Affiche la listes de commits (avec graph, auteur, temps écoulé, références)
    ls = log --pretty=format:'%C(yellow)%h %C(green)[%ad]%C(bold red)%d %Creset%s%C(cyan) [%cn]' --decorate --date=relative
    # Affiche la listes de commits (avec graph, auteur, date absolue, références, note du commit)
    ln = log --pretty=format:'%C(yellow)%h %C(green)%ad%C(bold red)%d %Creset%s%C(cyan) [%cn]%C(magenta) %N' --decorate --date=short --graph
    # Affiche les commits (avec hash, message, date, auteur, parents, références)
    lpa = log --pretty=format:'%C(yellow)%h%Creset | %Cgreen%<(30,trunc)%s%Creset | %Cblue%ad%Creset | %C(red)%an%Creset | %C(cyan)%p%Creset | %C(magenta)%D%Creset' --date=iso

    # ----- GESTION DES BRANCHES
    # Change de branche
    co = checkout
    # Créer une nouvelle branche et se place dedans
    cb = checkout -b
    # Supprime une branche locale
    bd = branch -d
    # Supprimer une branche locale et push la suppression
    bdp = !sh -c 'git branch -D $1 && git push origin :$1' -
    # Fusion sans avance rapide
    mnff = merge --no-ff
    # Restaure un fichier à l'état qu'il avait sur l'ancêtre commun avec develop
    restore-bb = !git checkout $(git merge-base develop $(git rev-parse --abbrev-ref HEAD))
    # Génère les différences avec l'ancêtre commun de la branche develop
    diff-bb = !git diff $(git merge-base develop $(git rev-parse --abbrev-ref HEAD))
    # Execute un git reset --soft avec l'ancêtre commun de la branche develop
    reset-soft-bb = !git reset --soft $(git merge-base develop $(git rev-parse --abbrev-ref HEAD))
    # Permet un rebase --onto facile. Il faut se placer sur la branche et rebase et donner en argument le nom de la nouvelle base
    rebaseon = "!f() { git rebase --onto \"$1\" $(git merge-base \"$1\" $(git rev-parse --abbrev-ref HEAD)) $(git rev-parse --abbrev-ref HEAD); }; f"
    # Affiche l'état d'un rebase en cours (commits à rebase / commits totaux)
    rebase-status = "!f() { total=$(git rev-list --count HEAD); remaining=$(git rev-list --count ORIG_HEAD ^HEAD); echo \"$remaining / $total\"; }; f"

    # ----- STASH (mettre de côté des modifications)
    # Met de côté les modifications actuelles des fichiers suivis
    ss = stash save
    # Met de côté les modifications actuelles de tous les fichiers non ignorés
    ssu = stash save -u
    # Affiche le dernier stash (ou le stash passé en paramètre)
    sr = stash show
    # Affiche le dernier stash et son patch (ou le stash passé en paramètre)
    sp = stash show -p
    # Affiche la liste des stash
    sl = stash list
    # Affiche la liste des stash plus détaillé
    slv = "!f() { git stash list --pretty=format:\"%C(green)%h%C(reset) - %C(dim yellow)(%C(bold cyan)%gd%C(dim yellow))%C(reset) %<(70,trunc)%s %C(green)(%cr) %C(bold blue)<%an>%C(reset)\"; }; f"
    # Applique au répertoire de fichier le dernier stash (ou le stash passé en paramètre) et supprime le stash
    sp = stash pop
    # Applique au répertoire de fichier le dernier stash (ou le stash passé en paramètre)
    sa = stash apply
    # Créé une nouvelle branche avec les données du dernier stash (ou le stash passé en paramètre)
    sb = stash branch
    # Supprime le dernier stash (ou le stash passé en paramètre)
    sdf = stash drop
    # Permet de lire un stash selon un texte dans le titre du stash (Utile lorsqu'on nomme ses stash)
    srr = "!f() { git stash show stash^{/$*} -p; }; f"
    # Permet d'appliquer et supprimer un stash selon un texte dans le titre du stash (Utile lorsqu'on nomme ses stash)
    spr = "!f() { git stash pop stash^{/$*}; }; f"
    # Permet d'appliquer un stash selon un texte dans le titre du stash (Utile lorsqu'on nomme ses stash)
    sar = "!f() { git stash apply stash^{/$*}; }; f"
    # Permet de supprimer un stash selon un texte dans le titre du stash (Utile lorsqu'on nomme ses stash)
    sdr = "!f() { git stash drop stash^{/$*}; }; f"

    # ----- NOTES
    # Ajoute une note à HEAD (ou commit spécifié)
    na = notes add
    # Liste les notes
    nl = notes list
    # Ajoute du contenu à une note existante (HEAD ou commit spécifié)
    napp = notes append
    # Permet d'éditer une note
    ne = notes edit
    # Affiche la note de HEAD (ou commit spécifié)
    ns = notes show
    # Supprime la note de HEAD (ou commit spécifié)
    nr = notes remove
    # Permet de créer la note ReadyToMerge à un commit
    ready = notes add -m "ReadyToMerge" -f
    # Permet d'envoyer les notes au dépôt distant
    pushnotes = "!f() { git push \"$1\" refs/notes/*:refs/notes/*;}; f"

    # DIVERS
    # Affiche le dernier commit
    last = log -1 HEAD
    # Ajouter un tag annoté
    tg = tag -a
    # Permet d'envoyer les modifications avec les tags
    pu = "!sh -c 'parent=$(git for-each-ref --format=\"%(refname:short)\" --contains HEAD@{1} | sed -n 1p) && ancestor=$(git merge-base $parent HEAD) && files=$(git diff --name-only $ancestor HEAD | xargs grep -l \"TODOSD\") && if [ -n \"$files\" ]; then echo \"Error: The text \\\"TODOSD\\\" is present in one or more files between the common ancestor and the current branch:\"; echo \"$files\"; exit 1; else git push; fi'"
    # Affiche les options de configuration actives et leur fichier d'origine
    getconfig = config --list --show-origin
    # Commande inspirée de Mercurial qui permet d'afficher le nombre de lignes commitées par auteur.
    churn = "!f() { git ls-files -z | xargs -0n1 git blame -w --line-porcelain | grep -a "^author\\ " | sort -f | uniq -c | sort -nr;}; f"
    # Affiche les informations étendues relatives à un commit
    lvc = "!f() { git ld -1 $1;git log --pretty=raw -1 $1; git branch --contains $1; }; f"
    # Affiche les alias en configuration
    aliases = config --get-regexp alias
    # Affiche le reflog avec les dates
    reflogv = reflog --date=local
    # Envoi d'une nouvelle branche locale
    pushn = !git push --set-upstream origin $(git rev-parse --abbrev-ref HEAD)


